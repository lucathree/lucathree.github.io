---
title: "Python 기초 - 7.입출력"
layout: single
author_profile: true
read_time: true
related: true
categories:
- Python
tags:
- Python
- Study Note
- 플레이데이터
- 인공지능SW개발자과정
---


## 입출력

입력: 데이터를 키보드나 마우스 등을 통해 프로그램으로 들여보내는 것 (데이터가 외부에서 프로그램 방향으로 흘러옴)

출력: 입력받은 데이터를 프로그램이 처리하여 결과를 돌려보내는 것 (데이터가 프로그램에서 외부로 흘러나감)

**스트림 - 데이터가 입력되어 프로그램으로 들어오거나 프로그램에서 외부로 출력되는 과정/흐름 (**데이터의 흐름을 소프트웨어로 구현한 것)

### 표준입출력

- STDIO (Standard Input Output)

- 기본 제공 입출력

- sys **모듈***을 사용

  **모듈**- 특정 기능들(함수, 변수, 클래스 등)이 구현되어있는 파일을 의미 **패키지 -** 특정 기능과 관련된 여러 모듈을 하나의 상위폴더에 넣어 놓은 것. 패키지 안에 여러가지 폴더가 더 존재할 수 있음. **라이브러리 -** 여러 모듈과 패키지를 묶어서 라이브러리라고 호칭

  ```python
  import sys  #sys 모듈 가져오기
  
  sys.stdin  #표준입력
  sys.stdout  #표준출력
  sys.stderr  #표준에러 (에러메시지 출력, 버퍼 유무의 차이 외 표준출력과 동일)
  
  sin = sys.stdin  #키보드 입력 스트림 세팅
  sout = sys.stdout  #콘솔 출력 스트림 세팅
  serr = sys.stderr  #콘솔 에러 출력 스트림 세팅
  (입,출력 장치로부터 CPU로 데이터를 보낼 통로를 뚫는다고 생각하면 될 듯.
  강사님 표현으로는 '빨대를 꽂는다'ㅎㅎ)
  ```

  - sys.stdin: 표준입력
  - sys.stdout: 표준출력
  - sys.stderr: 표준에러 (에러메시지 출력, 버퍼 유무의 차이 외 표준출력과 동일)

- 파이썬의 print(), input() 같은 함수들은 시스템 함수를 활용해서 만들어진 입출력이 혼합된 함수. 일종의 모듈이라고 볼 수 있고, print()나 input()이 없었다면 이렇게 표준입출력을 사용해야한다.

  ```python
  #표준입출력 동작 예시
  sin = sys.stdin
  sout = sys.stdout
  serr = sys.stderr
  
  num = sout.write('문자를 입력하시오\\n')  #'문자를 입력하시오'출력
  sout.write(str(num)+'개의 문자 출력됨\\n')  #띄어쓰기와 줄바꿈까지 포함하여 '문자를 입력하시오\\n' 총 10개의 문자가 출력됨을 출력
  s = sin.read(4)  #read(size):입력 스트림에서 size만큼만 읽음. 일종의 버퍼.
  sout.write('입력받은 값:'+s+'\\n')  #'가나다라마바사'를 위에서 입력했을 때 결과로 '입력받은 값:가나다라' 출력
  sout.write('한줄을 입력하시오\\n')  #입력메시지 출력
  sin.readline()  #입력받음
  s = sin.readline()  #위 입력값을 s에 저장
  sout.write('입력받은 값:'+s+'\\n')  #입력값 출력
  serr.write('에러 메시지')  #에러 메시지 출력. 다만 에러출력은 버퍼가 없기 때문에 바로 윗줄보다 에러 메시지가 먼저 출력되는 현상 발생
  ```

- **버퍼**

  버퍼 = 임시 저장 공간 유튜브를 볼 때 아래 재생바에서 빨간부분이 현재 재생중인 부분, 그 뒤가 영상의 나머지라면, 회색으로 미리 다운받아져 있는 부분이 버퍼라고 볼 수 있다. 입,출력을 하는 내용 전체가 동여상의 재생바라면, CPU에서 처리되고 있는 부분이 영상재생의 빨간 부분이고, CPU가 처리하기 전 입력된 내용을 미리 받아서 저장하고 있는 임시 저장 공간이 버퍼인 것! 참고: https://dololak.tistory.com/84, https://tcpschool.com/c/c_io_console

  - 풀버퍼 (Fully buffer) - 버퍼에 일정 블록 이상이 될 때까지 쌓아두었다가 사용
  - 라인버퍼 (Line buffer) - 개행문자(줄바꿈문자)가 입력될 때마다 사용, 표준입출력 대부분 라인버퍼가 사용된다
  - unbuffer - 버퍼링을 하지 않고 바로바로 사용



## 파일입출력

**파일 오픈**

```python
open(파일경로, 모드)  #모드 기본은 r
예) file = open('a.txt','r')
```

- 모드종류
  - r : 읽기. 모드 지정을 안하면 기본 읽기 모드로 지정됨. 파일이 없으면 에러
  - w : 쓰기. 파일이 없으면 새로생성, 있으면 파일 내용을 지우고 새로씀
  - x : 쓰기인데 파일이 있으면 에러 발생
  - a : 이어쓰기. 파일이 없으면 새로쓰고 있으면 내용을 이어서 씀
  - t : 텍스트 파일 모드로 파일열기. 지정하지 않으면 기본적으로 텍스트 모드로 지정됨.
  - b : 바이너리 파일 모드로 파일열기.
  - r+, w+, a+ : 읽고쓰기

**파일 읽기/쓰기**

```python
#읽기
read()  #파일 전체를 읽어서 반환
read(size)  #size 크기만큼 파일에서 읽어서 반환
readline()  #한줄 읽어서 반환

#쓰기
write(출력값)  #파일에 출력값을 씀
writelines(출력값)  #출력값 부분에 리스트나 튜플 등을 넣으면 리스트나 튜플 안에 들어있는 값들을 씀
```

**파일 닫기**

```python
file.close()
```

- 파일 사용이 끝나면 파일을 닫아야한다.

- 안 닫아도 코드 진행에는 문제가 없으나, 파일을 안 닫은 상태로 다시 파일을 열려고 하거나 다른 파일을 열면 에러가 발생함

- **with 문 사용**

  ```python
  with open(경로, 모드) as f:
  		실행문...
  ```

  - with 문을 사용하면 자동으로 파일을 닫아주기 때문에 f.close() 를 안해도 됨
  - with 문 안에서 읽기/쓰기를 진행하고 반복문도 사용 가능

- \#r(읽기,파일 없으면 에러), w(쓰기,파일이 없으면 새로생성.있으면 파일 내용 지우고 새로씀), a(이어쓰기,파일 없으면 새로쓰고 있으면 이어쓰기) #t(텍스트), b(바이너리) #r+(읽고쓰기), w+(읽고쓰기), a+(읽고쓰기)

**경로표현**

1. 절대경로

   예) 'C:\\users\\clee0627\\projects\\...'

   - 파이썬에서 역슬래쉬가 텍스트임을 인지시키기 위해 두번씩 넣어줘야 함

   - 오히려 정방향 슬래쉬를 써서 표현해도 아무문제 없다

     → 'C:/users/clee0627/...'

2. 상대경로

   현재 프로그램 위치를 기준으로 해당 파일을 찾아감

   - ./ : 현재 디렉토리
   - ../ : 상위 디렉토리

   예를 들어, 현재 실행중인 파일이 D:/PythonProject/Day7/test.py 라면

   - 현재 디렉토리(./) 는 'D:/PythonProject/Day7'
   - 디렉토리를 찾아가고 싶으면 디렉토리명 → 하위 디렉토리 순으로 명령
     - 같은 폴더의 다른 파일: './test2.py'
     - 하위 폴더의 파일: './files/a.txt'
     - 동일 순위 다른 폴더의 파일: '../Day6/practice.py'

**파일 내 위치 제어**

파일 안에서 읽거나 쓰고 싶은 위치를 제어하는 방법

```python
tell()  #현재 위치 반환
seek(off, whence)  #whence를 기준으로 off만큼 떨어진 위치로 이동
```

- whence
  - 0 : 맨 앞
  - 1 : 현 위치
  - 2 : 맨 뒤
- seek() 안의 값은 byte 단위로 이동하기 때문에 파일을 열 때 모드를 'rb'로 해줘야 함

**파일 관리**

```python
1.파일절삭 - 지정한 크기로 파일 단편화
파일.truncate(size)

#아래 내용들은 os 모듈을 가져와야 사용가능
import os

2)파일명 바꾸기
os.rename(old, new)

3)파일 삭제
os.remove(파일명)

4)현재 작업디렉토리
os.getcwd()

5)작업디렉토리 변경
os.chdir(path)

6)디렉토리 생성
os.mkdir(path)

7)디렉토리 삭제
os.rmdir(path)

8)디렉토리 안에 있는 파일 목록
os.listdir(path)

9)파일 존재 확인
os.path.isfile(path) -> 파일 있으면 True, 없으면 False

10)디렉토리 존재 확인
os.path.isdir(path)
```

