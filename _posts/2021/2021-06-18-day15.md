---
title: "[AI교육과정] Day 15 - MySQL 뷰, 인덱스, 스토어드 프로시저, 함수, 커서, 트리거"
layout: single
author_profile: true
read_time: true
related: true
categories:
- Study Note
tags:
- 공부기록
- 인공지능SW개발자과정
- MySQL
toc: true
toc_sticky: true
---


## **뷰(VIEW) : 가상 테이블**

1. 복잡한 쿼리를 가상 테이블인 뷰로 만들면 사용이 간단해진다
2. 보안에 도움 (사용자의 레벨에 따라 접근 레벨을 분류할 수 있음)
3. 데이터의 독립성을 유지

※ 뷰를 이용한 쓰기 작업은 하지 않는 것이 좋다 (본 테이블에 데이터가 누락될 수 있음)

```sql
#뷰 생성하기
#똑같은 이름의 뷰가 있을 경우 replace를 써서 기존 뷰를 날리고 새로운 뷰 생성

create [or replace] view 뷰이름
as 서브쿼리

예)
create or replace view view_80
as
select employee_id as emp_id, last_name as name, salary
from employees
where department_id=80;
```

　

## **인덱스(Index)**

빠른 검색을 제공하기 위해 지정된 컬럼값을 "B-트리"로 구성

- unique 나 primary key를 설정하면 자동으로 인덱스가 생성된다.
- 인덱스는 질의 성능을 높이기 위한 목적으로 사용되지만, 너무 많은 컬럼을 지정하거나 아무 컬럼을 인덱스로 지정하면 오히려 성능이 떨어질 수 있다.
  - 장점
    1. 검색 속도가 무척 빨라질 수 있다. (단, 항상 그런 것은 아니다)
    2. 위 결과로 쿼리의 부하가 줄어들어서 시스템 전체의 성능이 향상된다.
  - 단점
    1. 인덴스가 데이터베이스 공간을 차지해서 추가 공간이 필요한데, 대략 데이터베이스의 10% 정도 추가 공간이 필요하다.
    2. 처음 인덱스 생성에 시간이 많이 소요될 수 있다.
    3. 데이터 변경작업 (insert, update, delete)가 자주 일어나는 경우 오히려 성능이 나빠진다.
  - 인덱스가 없을 경우 데이터를 찾으려면 테이블 전체를 검색하는 **Full Table Scan**을 할 수 밖에 없고, 데이터가 많을 경우 시스템에 과부하를 초래한다.
- 인덱스 설정 기준
  1. 인덱스는 자주 수정 및 삭제가 되지 않는 컬럼을 기준으로 만드는 것이 좋다.
  2. where 절로 검색했을 때 검색 결과로 나오는 행이 몇줄 안되는 컬럼

　

## 스토어드 프로시져 (Stored Procedure)

MySQL에서 제공해주는 프로그래밍 기능으로, SQL문을 하나로 묶어서 편리하게 사용하거나 프로그래밍 언어와 같은 기능을 담당할 수도 있다.

⇒ 간단하게 말해서, 파이썬에서의 함수와 같은 기능을 한다고 보면 된다.

**특징:**

- MySQL의 성능을 향상시킬 수 있다. → 쿼리 텍스트 길이를 줄여주기 때문에 네트워크의 부하를 줄일 수 있다.
- 유지관리가 간편하다.
- 모듈식 프로그래밍이 가능하다.
- 보안을 강화할 수 있다.

```sql
DELIMITER $$
CREATE PROCEDURE 프로시저명(파라미터 리스트)
BEGIN
	실행문
END $$
DELIMITER ;

CALL 프로시저명()
```

⇒ stored procedure 목록에서 우클릭, 'create stored procedure'를 사용하면 DELIMITER 사용없이 편리하게 생성가능

**변수선언**

```sql
SET @변수이름 = 값;
SELECT @변수이름;
```

- 스토어드 프로시저 안에서는 DECLARE 문으로 '@'없이 변수명만으로 선언해서 사용.

  → @변수는 전역변수, DECLARE 변수는 지역변수처럼 생각하면 된다.

  　

## 함수(Function)

스토어드 프로시저와 유사하지만 형태와 사용 용도에서의 차이가 있다.

- 스토어드 프로시저의 파라미터와 달리 IN, OUT을 사용할 수 없다. 함수의 파라미터는 모두 입력 파라미터로만 사용된다.
- RETURNS문으로 반환할 값의 데이터 형식을 지정하고, 본문 안에서는 RETURN문으로 하나의 값을 반환해야 한다.
- 스토어드 프로시저는 CALL로 호출, 함수는 SELECT 문장 안에서 호출.
- 스토어드 프로시저는 안에 SELECT문을 사용할 수 있지만 함수는 SELECT를 사용할 수 없다
  - 예외적으로 집합 결과를 반환하지 않는 SELECT ... INTO ... 는 사용할 수 있다.
- 스토어드 프로시저 = 반복되는 과정을 담기 위한 용도, 함수 = 계산을 통해 하나의 값을 반환받기 위한 용도

```sql
-- 우선 스토어드 함수 생성 권한을 아래 쿼리문으로 허용해야한다.
SET GLOBAL log_bin_trust_function_creators = 1;

-- 함수 정의
DELIMITER $$
CREATE FUNCTION 함수명(파라미터 리스트)
	RETURNS 반환형식
BEGIN
	실행문
	RETURN 반환값;
END $$
DELIMITER ;

SELECT 함수명()
```

　

## 커서(Cursor)

테이블에서 여러 개의 행을 쿼리한 후에, 쿼리의 결과인 행 집합을 한 행씩 처리하기 위한 방식.

여러 줄, 여러 컬럼으로 구성된 검색결과.

일반적으로 알고있는 '커서'의 개념처럼 현재 작업중인 위치를 가리키며 한 줄씩 검색을 진행한다.

**커서의 처리 순서:**

1. 커서 선언 (DECLARE CURSOR)
2. 반복 조건 선언 (DECLARE CONTINUE HANDLER); 더 읽을 행이 없을 경우 실행할 내용 설정
3. 커서 열기 (OPEN)
4. 커서에서 데이터 가져오기 (FETCH)
5. 데이터 처리
6. 커서 닫기 (CLOSE)

```sql
CREATE PROCEDURE 프로시저명()
BEGIN
		DECLARE 변수명 타입; -- 커서로 행을 읽어서 값을 대입시킬 변수 선언
    DECLARE 마침변수명 BOOLEAN DEFAULT FALSE; -- 검색할 테이블 행의 끝 도달 여부확인용
		
		DECLARE 커서명 CURSOR FOR SELECT 컬럼명 FROM 테이블명; -- 1.커서 선언
    
		DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; -- 2.반복 조건 선언
    # cursor에서 한 줄씩 fetch. 언제까지? not found(커서에 읽을 줄이 더 없다)까지.
    # open => fetch(한줄씩출력):반복 => not found 도달 => close
    
		OPEN 커서명;  -- 3.커서 열기
    
		루프명: LOOP  -- 반복구간 지정
				FETCH FROM 커서명 INTO 변수명; -- 4.커서에서 한 줄씩 읽어서 5.변수에 값 저장
        IF 마침변수명
						THEN LEAVE 루프명;  -- 더 이상 읽을 행이 없어 'NOT FOUND'가 되면 루프 종료
        END IF;

        SELECT 변수명;  -- 변수값 출력
		END LOOP;
    CLOSE 커서명; -- 6.커서 닫기
END
```

　

## 트리거(Trigger)

테이블에 부착되어 INSERT, UPDATE, DELETE 작업이 발생되면 실행되는 코드

제약조건처럼 데이터의 무결성을 위한 기능으로 주로 활용된다.

- 테이블이 수정되었을 때의 내용들을 기록
- 테이블이 수정되기 전 입력될 데이터 값을 미리 확인

```sql
CREATE TRIGGER 트리거이름
	{BEFORE|AFTER) {INSERT|UPDATE|DELETE} -- 작동 시기(전/후), 작동할 동작 선택
	ON 테이블명
	FOR EACH ROW
BEGIN
	실행문;
END
```
